##定义简单工厂
简单工厂其实不是一个设计模式，反而像是一种编程习惯（将创建类的方法封装到一个新的类中）

在超类中定义创建对象的抽象方法，让子类决定具体创建哪个类，从而达到解耦（decouple）的目的。

## 工厂方法
工厂方法用来处理对象的创建，并将这样的行为封装在子类中。这样，客户程序中关于超类的代码就和子类对象创建代码解耦了。

abstract Product factoryMethod(String type)
1. 工厂方法必须是抽象的，由子类处理对象的创建
2. 工厂方法必须返回一个产品。超类中定义的方法，通常使用到工厂方法的返回值。
3. 工厂方法将客户（也就是超类中的代码，orderPizza()）和实际创建具体产品的代码分隔开来。


## 定义工厂方法模式
定义了一个创建对象的接口，但由于子类决定要实例化的类是哪一个，工厂方法让类把实例化推迟到了子类。


工厂方法模式能够封装具体的类型的实例化。是指在编写创建者类时，不需要知道实际创建的产品是哪一个。选择了哪个子类，自然就决定了实际创建的产品是什么。


### 针对简单工厂，和工厂方法之间的差异，
简单方法的子类看起来很像简单工厂，简单工厂把全部的事情，在一个地方处理完了，然而工厂方法却是创建一个框架，让子类决定要如何实现。

## 设计原则
要依赖抽象，不要依赖具体类。

Dependency Inversion Principle

这个原则说明了，不能让高层组件依赖底层组件，不管高层或者低层组件，“二者”都应该依赖于抽象。所谓“高层”组件，是由其他低层组件定义行为的

为了遵循依赖倒置原则：
1. 变量不可以持有具体类的引用。如果使用new，就会持有具体类的引用，可以改用工厂来避开这样的做法。
2. 不要让类派生自具体类。如果派生自具体类，就会依赖具体类，需要派生自抽象（接口或者抽象类）
3. 不要覆盖基类中已实现的方法。如果覆盖基类已经实现的方法，那么基类就不是一个真正适合被继承的抽象。基类中已经实现的方法，应该由所有子类共享。

## 定义抽象工厂模式
提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。

抽象工厂允许客户使用抽象的接口来创建一组相关的产品，而不需要知道（关心）具体创建产品过程（从类名就可以知道），让客户从具体的产品中被解耦。