利用继承设计子类的行为，是在编译时静态决定的，而且所有的子类都会继承相同的行为，然而，如果能够利用组合的做法扩展对象的行为，就可以在运行时动态的扩展。

###开放-关闭原则
类应该对扩展开放，对修改关闭。

我们的目标是允许类容易扩展，在不修改现有代码的情况下，就可以搭配新的行为，composition and delegation

应该设计具有弹性的代码应对改变，可以接受新的功能来应对改变的需求。
虽然似乎有些矛盾，但是的确有一些技术可以允许在不直接修改代码的情况下对其进行扩展。但是如果每个地方都采用开放-关闭原则，是一种浪费，也没必要，还会导致代码复杂且难以理解。

装饰者模式解决的问题，（类数量爆炸，设计死板，以及基类加入的新功能并不能适用于所有的子类。）

## 装饰者模式
动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。


装饰者和被装饰者必须是一样的类型，也就是有共同的超类， 这里利用继承达到“类型匹配”，而不是利用继承获得“行为”。
